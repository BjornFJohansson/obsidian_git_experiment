
#!/usr/bin/env python3
# Simple logging system additions
import sys
import re
import subprocess
from pathlib import Path
from datetime import datetime
import os
# from urllib.parse import quote
# https://help.obsidian.md/Files+and+folders/Accepted+file+formats

# --- Logging Setup ---
LOG_FILE = Path("sync.log")
MAX_LOG_SIZE = 1 * 1024 * 1024  # 1MB
def rotate_log():
    if LOG_FILE.exists() and LOG_FILE.stat().st_size > MAX_LOG_SIZE:
        backup = LOG_FILE.with_suffix(".log.1")
        if backup.exists():
            backup.unlink()
        LOG_FILE.rename(backup)
        LOG_FILE.write_text("")

def log(msg, level="INFO"):
    rotate_log()
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    entry = f"[{timestamp}] [{level}] {msg}\n"
    with LOG_FILE.open("a", encoding="utf-8") as f:
        f.write(entry)
    if level == "ERROR":
        print(entry, file=sys.stderr)
    else:
        print(entry, end="")

log("RUNNING POST-COMMIT...")


# subprocesses to execute git command and return output, vars hold output
try:
    branch = subprocess.check_output("git rev-parse --abbrev-ref HEAD", shell=True, timeout=300)
    msg = subprocess.check_output("git log -1 --pretty=%B", shell=True, timeout=300).strip().decode()
    log(f"Current branch: {branch.decode().strip()}")
    log(f"Last commit message: {msg}")
except Exception as e:
    log(f"Failed to get branch or commit message: {e}", level="ERROR")
    sys.exit(1)


# assign script name to script, assign any additional argumnents to args
script, *args = sys.argv # contains list of CLAs passed to script

# retrieve last argument from args
arg = args.pop() if args else None

if arg == "obsidian":
    arg = None


# if branch argument IS provided
if arg:
    # if current branch !== given argument branch, exit
    if branch != bytes(arg + "\n", "utf8"):
        log(f"Not on given branch: {arg}", level="ERROR")
        sys.exit(0)
    log(f"On given branch: {arg}")
    mdfiles = sorted(Path(".").glob("**/*.md"))
    log(f"All files: {mdfiles}")


# if  branch argument IS NOT provided
else:
    # if branch is not obsidian branch, exit
    if branch != b"obsidian\n":
        log("Branch is not obsidian", level="ERROR")
        sys.exit(0)
    log(f"On {branch.decode().strip()}")

    # retrieve list of files changed in last commit
    try:
        header, *filenames = subprocess.check_output("git log -1 --stat --oneline --name-only", shell=True).splitlines()
        allfiles = [Path(f.decode()) for f in filenames]
        mdfiles = [p for p in allfiles if p.suffix == ".md" and p.is_file()]
        log(f"Files in last commit: {allfiles}")
    except Exception as e:
        log(f"Failed to get files from last commit: {e}", level="ERROR")
        sys.exit(1)
  
    # assign file names from allfiles WITHOUT .md extension, to otherfiles
    otherfiles = [p for p in allfiles if p.suffix != ".md" and p.is_file()]

    # checkout to ob_to_gh
    try:
        subprocess.run("git checkout ob_to_gh", shell=True, timeout=300, check=True)
        log("Checked out to ob_to_gh branch.")
    except Exception as e:
        log(f"Failed to checkout ob_to_gh: {e}", level="ERROR")
        sys.exit(1)

    # join file paths in mdfiles and otherfiles into space-separated string, assign to paths
    # manually wrap each path in double quotes to handle spaces when shell=True.
    # note: this is kind of a hack fix, filenames with quotes or other complex shell characters are not accounted for
    paths = " ".join(f'"{str(p)}"' for p in mdfiles + otherfiles)

    # checkout files, specified in paths, from obsidian branch to ob_to_gh branch
    if paths:
        try:
            subprocess.run(f"git checkout obsidian -- {paths}", shell=True, timeout=300, check=True)
            log(f"Checked out files from obsidian: {paths}")
        except Exception as e:
            log(f"Failed to checkout files from obsidian: {e}", level="ERROR")
    elif mdfiles or otherfiles:
        log("Warning: Files were identified, but the 'paths' string for git is unexpectedly empty. Skipping checkout from obsidian.", level="ERROR")
    else:
        log("No specific files identified in the last commit to checkout from obsidian branch.")


# PAGE LINK CONVERSION
# start message
log("[[file name|link text]] --> [[link text|file-name]]")

# define function to modify Obsidian page links
# m represents argument
def switch_fn_linktext(m):
    # access third captured group from regex match, expecting link text from Obsidian link
    linktext = m.group(3)
    # access second captured group from regex match, expecting file name from Obsidian link
    # replace any spaces in pagename with hyphens
    pagename = m.group(2).replace(" ", "-")
    # form replacement string (first captured group + transformed wikilink)
    sub = f"{m.group(1)}[[{linktext}|{pagename}]]"
    log(f"Page link conversion: {sub}")
    return sub

# loop to iterate through mdfiles, applying function switch_fn_linktext
for file in mdfiles:
    # store original text
    original_text = file.read_text(encoding='utf-8')
    # apply function using re.sub to perform substitutions
    #                 "([^!])\[\[([^#|[]+?)\|([^#|[]+?)\]\]"
    newtext = re.sub(r"([^!])\[\[([^[]+?)\|([^#|[]+?)\]\]", switch_fn_linktext, original_text)
    if newtext != original_text:
        pass
        file.write_text(newtext, encoding='utf-8')

# HEADER LINK CONVERSION
# start message
log("[[#Some header in the page|some text]] --> [some text](#some-header-in-the-page)")

# define function to modify Obsidian header links
def links_to_header(m):
    linktext = m.group(2)
    pagename = m.group(1).replace(" ", "-").lower()
    # form replacement string
    sub = f"[{linktext}]({pagename})"
    log(f"Header link conversion: {m.group(0)} -> {sub}")
    return sub


for file in mdfiles:
    # store original text
    original_text = file.read_text(encoding='utf-8')
    # original_text = "  [[#Some header in the page|some text]]"
    newtext = re.sub(r"[^!]\[\[(#[^#|[]+?)\|([^#|[]+?)\]\]", links_to_header, original_text)
    if newtext != original_text:
        pass
        file.write_text(newtext, encoding='utf-8')


# IMAGE LINK CONVERSION
# start message
log("![[some image.png]] --> [[some image.png]]")

# define function to modify Obsidian image links
def remove_exclamation_mark(m):
    sub = " " + m.group(2)  # .replace(" ", "-")
    log(f"Image link conversion: {sub}")
    return sub


for file in mdfiles:
    original_text = file.read_text(encoding='utf-8')
    # original_text = "[![[EGB24-20240705161734646.png]]](https://www.instagram.com/spettsart/?hl=en)" # "x![[some image.png]]"    # "([^[])!(\[\[.+\]\])"
    newtext = re.sub(r"(!)(\[\[.+\]\])", remove_exclamation_mark, original_text)
    if newtext != original_text:
        pass
        file.write_text(newtext, encoding='utf-8')


# for i, file in enumerate(mdfiles):
#     quoted = quote(file.name, safe=" ():")
#     if file.name != quoted:
#         print("  name", file.name)
#         print("rename", quoted)
#         print(file)
#         print()
#         file.rename(quoted)
#         mdfiles[i] = file


# if no branch argument provided
if not arg:

    commands = ("git add --all",
                f"git commit -m \"{msg}\"",  
                "git checkout master",
                "git pull",
                "git merge --strategy-option theirs ob_to_gh",
                "git push origin master",
                "git checkout obsidian",)

    for command in commands:
        try:
            subprocess.run(command, shell=True, timeout=300, check=True)
            log(f"Ran command: {command}")
        except Exception as e:
            log(f"Failed to run command '{command}': {e}", level="ERROR")